#!/usr/bin/perl

# ===============================
# Функция: чтение массива
# ===============================
sub read_array {
    my $prompt = shift;  # shift берёт первый аргумент функции (@_ – список аргументов)
    print "$prompt (по одному элементу на строку, пустая строка — окончание ввода):\n";
    my @arr;             # объявляем локальный массив
    while (my $line = <>) {   # <> читают строку из ввода
        chomp $line;     # chomp убирает символ конца строки \n
        last if $line eq ''; # eq – сравнение строк. Если строка пустая, завершаем ввод
        push @arr, $line; # push добавляет элемент в конец массива
    }
    return @arr;         # возвращаем массив (Perl всегда возвращает список последнего выражения)
}

# ===============================
# Удаление дубликатов из массива
# ===============================
sub unique_array {
    my @arr = @_;
    my @uniq;  # новый массив без повторов
    for my $el (@arr) {       # внешний цикл
        my $found = 0;        # флаг – найден ли элемент
        for my $u (@uniq) {   # проверяем среди уже добавленных
            if ($u eq $el) 
            {
                $found = 1; 
                last; 
            } # eq – сравнение строк, last – выход из цикла
        }
        if (!$found) {             # если НЕ найден
            push @uniq, $el;       # добавляем в массив уникальных
        }
    }
    return @uniq;
}

# ===============================
# Теоретико-множественные операции
# ===============================
sub operations_sets {
    my ($a1, $a2) = @_; # принимаем ссылки на массивы

    # Объединение
    my @union = unique_array(@A, @B);

    # Пересечение
    my @intersection;
    for my $x (@A) {
        for my $y (@B) {
            if ($x eq $y) {  # сравнение строк
                push @intersection, $x;
                last;        # прерываем внутренний цикл
            }
        }
    }
    @intersection = unique_array(@intersection);

    # Симметричная разность = (A-B) + (B-A)
    my @diff_ab = diff_arrays(\@A, \@B); # A - B
    my @diff_ba = diff_arrays(\@B, \@A); # B - A
    my @sym_diff = unique_array(@diff_ab, @diff_ba); # симметричная разность

    # Вывод результатов
    print "\n--- Результаты множеств ---\n";
    print "Объединение: @union\n";
    print "Пересечение: @intersection\n";
    print "Разность (array1 - array2): @diff_ab\n";
    print "Разность (array2 - array1): @diff_ba\n";
    print "Симметричная разность: @sym_diff\n";
}

# ===============================
# Универсальная разность массивов
# ===============================
sub diff_arrays {
    my ($arr1_ref, $arr2_ref) = @_;   # принимаем ссылки на массивы
    my @diff;

    for my $x (@arr1) {
        my $found = 0;
        for my $y (@arr2) {
            if ($x eq $y) {
                $found = 1;
                last;                 # нашли совпадение — выходим из внутреннего цикла
            }
        }
        if (!$found) {
            push @diff, $x;           # добавляем, если в arr2 такого элемента нет
        }
    }
    return @diff;
}

# ===============================
# Попарная перестановка элементов
# ===============================
sub swap_pairs {
    my @swapped = @_;  # копируем массив (разыменование ссылки)
    for (my $i = 0; $i+1 < @swapped; $i += 2) {
        # @array[$i,$i+1] – срез массива (подмассив по индексам)
        # Перестановка элементов местами:
        @swapped[$i,$i+1] = @swapped[$i+1,$i];
    }
    print "\n--- Попарная перестановка первого массива ---\n";
    print @swapped;
}

# ===============================
# Чередование массивов
# ===============================
sub merge_alternate {
    my ($a1, $a2) = @_;
    my $min = @$a1 < @$a2 ? @$a1 : @$a2; # тернарный оператор ?:
    my @merged;
    for my $i (0..$min-1) { # диапазон чисел от 0 до $min-1
        push @merged, $a1->[$i], $a2->[$i]; # -> доступ к элементу массива по ссылке
    }
    print "\n--- Чередующийся массив (до конца меньшего массива) ---\n";
    print @merged ? join(' ', @merged) . "\n" : "(пусто)\n";
}

# ===============================
# Меню работы с массивами
# ===============================
sub menu_arrays {
    my ($a1_ref, $a2_ref) = @_; # ссылки на массивы
    while (1) {
        print "\nМеню работы с массивами:\n";
        print "1. Операции множеств\n";
        print "2. Попарная перестановка\n";
        print "3. Чередующийся массив\n";
        print "4. Назад\n";
        print "Выберите действие: ";
        chomp(my $c = <STDIN>); # chomp убирает \n
        if ($c eq '1') {
            operations_sets(\@a1_ref, \@a2_ref);
        } elsif ($c eq '2') {
            swap_pairs(@a1_ref);
        } elsif ($c eq '3') {
            merge_alternate(\@a1_ref, \@a2_ref);
        } elsif ($c eq '4') {
            last; # выход из цикла while
        } else {
            print "Некорректный выбор.\n";
        }
    }
}

# ===============================
# Меню работы со строками (хеш)
# ===============================
sub menu_strings {
    my %strings; # % – хеш (ключ-значение)
    while (1) {
        print "\nМеню работы со строками (лексикографический порядок):\n";
        print "1. Добавить строку\n";
        print "2. Удалить строку\n";
        print "3. Показать список\n";
        print "4. Назад\n";
        print "Выберите действие: ";
        chomp(my $c = <STDIN>);
        if ($c eq '1') {
            print "Введите строку для добавления: ";
            chomp(my $s = <STDIN>);
            $strings{$s} = 1; # добавляем ключ в хеш. Дубликаты перезапишутся
            print "Добавлено.\n";
        } elsif ($c eq '2') {
            print "Введите строку для удаления: ";
            chomp(my $s = <STDIN>);
            if (exists $strings{$s}) { # exists – проверка наличия ключа
                delete $strings{$s};  # delete – удаление ключа
                print "Удалено.\n";
            } else {
                print "Такой строки нет.\n";
            }
        } elsif ($c eq '3') {
            print "Список (лексикографически):\n";
            my @out = sort keys %strings; # keys – список ключей хеша
            print @out ? join("\n", @out) . "\n" : "(пусто)\n";
        } elsif ($c eq '4') {
            last;
        } else {
            print "Некорректный выбор.\n";
        }
    }
}

# ===============================
# main
# ===============================
print "=== Ввод массивов ===\n";
my @array1 = read_array("Введите элементы первого массива");
my @array2 = read_array("Введите элементы второго массива");

while (1) {
    print "\nГлавное меню:\n1. Работа с массивами\n2. Работа со строками (хеш)\n3. Выход\nВыберите: ";
    chomp(my $ch = <STDIN>);
    if ($ch eq '1') {
        menu_arrays(\@array1, \@array2); # \@array – создание ссылки на массив
    } elsif ($ch eq '2') {
        menu_strings();
    } elsif ($ch eq '3') {
        last;
    } else {
        print "Некорректный выбор.\n";
    }
}
