# ==============================
# ГЛОБАЛЬНАЯ ПЕРЕМЕННАЯ
# ==============================

my $root;   # корень бинарного дерева поиска (изначально пустой = undef)

# ==============================
# ОСНОВНОЙ ЦИКЛ МЕНЮ
# ==============================

while (1) {                                # бесконечный цикл (будет работать, пока не выберем "Выход")
    print "\nМеню:\n";                     # печатаем меню
    print "1. Сгенерировать дерево случайных чисел\n";
    print "2. Добавить элемент\n";
    print "3. Вывести дерево (структура)\n";
    print "4. Вывести дерево (по уровням)\n";
    print "5. Удалить элемент\n";
    print "6. Выход\n";
    print "Ваш выбор: ";

    chomp(my $choice = <> );               # читаем ввод пользователя, убираем символ перевода строки

    if ($choice eq '1') {                  # пункт 1 — генерация случайного дерева
        print "Сколько чисел сгенерировать? ";
        chomp(my $n = <>);                 # читаем количество чисел

        $root = undef;                     # очищаем дерево (делаем пустым)
        for (1 .. $n) {                    # повторяем n раз
            my $val = int(rand(100));      # генерируем случайное число от 0 до 99
            insert(\$root, $val);          # вставляем его в дерево
        }
        print "Дерево сгенерировано.\n";
    }
    elsif ($choice eq '2') {               # пункт 2 — добавление элемента вручную
        print "Введите число: ";
        chomp(my $val = <>);               # читаем число пользователя

        insert(\$root, $val);              # вставляем его в дерево

        print "Элемент $val добавлен.\n";
    }
    elsif ($choice eq '3') {               # пункт 3 — вывод дерева структурой (боком)
        if ($root) {                       # если дерево не пустое
            print "\nСтруктура дерева:\n";
            print_tree($root, "", 0);      # печатаем дерево рекурсивно
        } else {
            print "Дерево пустое.\n";
        }
    }
    elsif ($choice eq '4') {               # пункт 4 — вывод дерева по уровням
        if ($root) {
            print "\nДерево по уровням:\n";
            print_tree_levels($root);      # печатаем дерево уровнями
        } else {
            print "Дерево пустое.\n";
        }
    }
    elsif ($choice eq '5') {               # пункт 5 — удаление элемента
        print "Введите число для удаления: ";
        chomp(my $val = <> // '');         # читаем число (если пусто, то '')

        if (delete_node(\$root, $val)) {   # пробуем удалить
            print "Элемент $val удалён.\n";
        } else {
            print "Элемент $val не найден.\n";
        }
    }
    elsif ($choice eq '6') {               # пункт 6 — выход
        last;                              # прерываем цикл → завершаем программу
    }
    else {
        print "Неверный выбор!\n";         # обработка ошибки ввода
    }
}

# ==============================
# ФУНКЦИИ ДЛЯ ДЕРЕВА
# ==============================

# ---------- Вставка ----------
# insert(\$node, $val)
# $node — ссылка на "ячейку" (undef или хеш-узел)
# $val  — число для вставки
sub insert {
    my ($ref, $val) = @_;                  # получаем ссылку на узел и значение

    unless ($$ref) {                       # если текущая ячейка пустая
        $$ref = { VALUE => $val,           # создаём новый узел: значение + пустые потомки
                   LEFT => undef,
                   RIGHT => undef };
        return 1;                          # вставка прошла успешно
    }

    if ($val == $$ref->{VALUE}) {          # если элемент уже существует
        warn "Элемент $val уже есть!\n";   # предупреждаем
        return 0;                          # не вставляем дубликаты
    }
    elsif ($val < $$ref->{VALUE}) {        # если значение меньше текущего
        # рекурсивно вставляем в ЛЕВОЕ поддерево
        return insert(\($$ref->{LEFT}), $val);
    }
    else {                                 # если значение больше
        # рекурсивно вставляем в ПРАВОЕ поддерево
        return insert(\($$ref->{RIGHT}), $val);
    }
}

# ---------- Красивый вывод ----------
# print_tree($node, $prefix, $is_left)
# Рекурсивно рисует дерево "боком"
sub print_tree {
    my ($node, $prefix, $is_left) = @_;
    return unless $node;                   # если узла нет → выходим

    # Сначала печатаем правое поддерево
    if ($node->{RIGHT}) {
        print_tree($node->{RIGHT}, $prefix . ($is_left ? "│   " : "    "), 0);
    }

    # Потом печатаем сам узел
    print $prefix;                         # выводим отступ
    print($is_left ? "└── " : "┌── ");     # рисуем "ветку" (слева/справа)
    print $node->{VALUE} . "\n";           # значение узла

    # В конце печатаем левое поддерево
    if ($node->{LEFT}) {
        print_tree($node->{LEFT}, $prefix . ($is_left ? "    " : "│   "), 1);
    }
}

# ---------- Высота дерева ----------
sub tree_height {
    my ($node) = @_;
    return 0 unless $node;                 # пустое дерево = высота 0
    # рекурсивно вычисляем высоту:
    # 1 (текущий узел) + макс(высота левого, высота правого)
    return 1 + max(tree_height($node->{LEFT}), tree_height($node->{RIGHT}));
}

# ---------- Сбор значений по уровням ----------
sub collect_levels {
    my ($node, $level, $levels) = @_;
    return unless $node;                   # если узла нет → выходим

    push @{ $levels->[$level] }, $node->{VALUE}; # добавляем значение в массив соответствующего уровня

    collect_levels($node->{LEFT},  $level + 1, $levels);  # рекурсивно идём влево, увеличивая уровень
    collect_levels($node->{RIGHT}, $level + 1, $levels);  # рекурсивно идём вправо
}

# ---------- Печать по уровням ----------
sub print_tree_levels {
    my ($root) = @_;
    return print "Дерево пустое.\n" unless $root; # если пустое

    my $h = tree_height($root);            # вычисляем высоту (инфо, можно не использовать)
    my @levels;                            # массив уровней
    collect_levels($root, 0, \@levels);    # собираем значения по уровням

    for my $i (0..$#levels) {              # печатаем все уровни
        print "Уровень $i: ";
        print join("  ", @{ $levels[$i] });
        print "\n";
    }
}

# ---------- Удаление ----------
sub delete_node {
    my ($ref, $val) = @_;
    return 0 unless $$ref;                 # если узел пустой → не нашли элемент

    if ($val < $$ref->{VALUE}) {           # если меньше → ищем в левом поддереве
        return delete_node(\($$ref->{LEFT}), $val);
    }
    elsif ($val > $$ref->{VALUE}) {        # если больше → в правом поддереве
        return delete_node(\($$ref->{RIGHT}), $val);
    }
    else {                                 # нашли нужный узел
        if (!$$ref->{LEFT} && !$$ref->{RIGHT}) {    # случай 1: лист
            $$ref = undef;                 # просто удаляем
        }
        elsif (!$$ref->{LEFT}) {           # случай 2: есть только ПРАВЫЙ потомок
            $$ref = $$ref->{RIGHT};        # заменяем узел правым
        }
        elsif (!$$ref->{RIGHT}) {          # случай 3: есть только ЛЕВЫЙ потомок
            $$ref = $$ref->{LEFT};         # заменяем узел левым
        }
        else {                             # случай 4: два потомка
            # ищем минимальное значение в правом поддереве
            my $min_ref = min_ref(\($$ref->{RIGHT}));
            $$ref->{VALUE} = $$min_ref;    # заменяем значение текущего узла
            # рекурсивно удаляем этот минимальный элемент в правом поддереве
            delete_node(\($$ref->{RIGHT}), $$min_ref);
        }
        return 1;                          # элемент удалён
    }
}

# ---------- Минимальный элемент ----------
sub min_ref {
    my ($ref) = @_;
    return $ref unless $$ref->{LEFT};      # если нет левого → нашли минимум
    return min_ref(\($$ref->{LEFT}));      # иначе рекурсивно идём влево
}
