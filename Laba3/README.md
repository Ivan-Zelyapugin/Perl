### Первая часть

```use strict;``` — заставляет Perl требовать явного объявления переменных (my, our). Это помогает избежать ошибок из-за опечаток в именах переменных.

```use warnings;``` — включает предупреждения. Если в программе что-то потенциально опасное или странное (например, использование неинициализированной переменной), Perl выдаст предупреждение.

```my $head;```Здесь объявляется скалярная переменная $head.

Она будет хранить ссылку на первый элемент (голову) односвязного списка студентов.

Сначала $head равен undef (список пуст). Когда вставляем первого студента, в $head кладётся ссылка на хэш с его данными.

```
my $MAX_YEAR = 2025;
my $MIN_YEAR = 1900;
```
Это ограничения для проверки даты рождения:



```chomp( my $choice = <> // '' );```
```<> ```читает строку из STDIN (пользователь вводит и нажимает Enter).

```// '' ```— оператор defined-or: если <> вернёт undef (например, на EOF при Ctrl-D), то вместо undef подставится пустая строка ''. Это предотвращает предупреждения/ошибки при chomp.

```chomp(...)``` удаляет завершающий символ новой строки \n из входа.

В результате в $choice всегда будет строка (возможно пустая), а не undef.


```$choice =~ s/^\s+|\s+$//g;```
Удаляем ведущие и завершающие пробелы (trim). Без этого ' 1 ' не равнялось бы '1'.

Регулярка удаляет пробелы/табуляции в начале и в конце.
```
^\s+     -> пробелы в начале строки
\s+$     -> пробелы в конце строки
|        -> либо одно, либо другое
s/...//g — это замена на пустую строку (//).

g (global) — заменяет все совпадения, хотя в данном случае регулярка найдёт только два возможных участка: начало и конец, так что g здесь формально не обязателен.
```
Сравнение ```eq ```— оператор строкового сравнения. Мы ожидаем ввод как строку (например, 1).
```
my %student = (
    FIO  => $fio,
    ZACH => $zach,
    GROUP => $group,
    SPEC => $spec,
    DOB  => $date,   # дата рождения
    NEXT => undef,
);
```
Формируем %student — анонимная запись (хеш) с полями:

FIO, ZACH (ключ), GROUP, SPEC, DOB — данные студента.

NEXT — указатель на следующий узел списка; undef для нового элемента.

Этот хеш затем передаётся в вставку.

if ( insert(\$head, \%student) ) {
    print "Студент добавлен.\n";
} else {
    print "Студент не добавлен (возможно, дублирование ключа).\n";
}
insert(\$head, \%student) — ВАЖНО:

```\$head``` — ссылка на скаляр $head.
\%student — ссылка на хеш студента (не копируем весь хеш).

Функция insert возвращает 1 при успешной вставке и 0 если, например, ключ (зачетка) уже существует — поэтому мы можем показать соответствующее сообщение.
```
elsif ($choice eq '2') {
    print "Введите № зачетной книжки для удаления: ";
    chomp( my $zach = <> // '' );
    $zach =~ s/^\s+|\s+$//g;
    if ($zach eq '') {
        print "Пустой ключ — отмена.\n";
    } else {
        if ( delete_node(\$head, $zach, undef) ) {
            print "Студент с № $zach удалён.\n";
        } else {
            print "Студент с № $zach не найден.\n";
        }
    }
}
```
Ветка удаления:

Читаем ключ zach, чомпим и обрезаем пробелы.

Если пользователь просто нажал Enter — считаем это отменой.

Иначе вызываем delete_node(\$head, $zach, undef):

Первый аргумент — снова ссылка на скаляр головы списка.

Второй — сам ключ (строка).

Третий — prev (предыдущий узел) — при вызове с головы передаём undef.

delete_node рекурсивно ищет узел и при удалении корректно перенастраивает указатели; возвращает 1, если удалил, иначе 0.
```
elsif ($choice eq '3') {
    print "\nСписок студентов:\n";
    list_print($head);
}
```
Ветка вывода:

```list_print($head)``` — печатает список рекурсивно, начиная с head. Передаётся текущий хеш-реф узла (или undef, если список пуст).

```list_print``` просто проходит по полям NEXT и печатает данные каждого узла.

elsif ($choice eq '4') {
    last;
}
else {
    print "Неверный выбор!\n";
}

```elsif ($choice eq '4') { last; }``` — выход из бесконечного цикла и завершение программы.

### Вспомогательный функции

#### trim 
```
sub trim { 
    my $s = shift // ''; 
    $s =~ s/^\s+|\s+$//g; 
    return $s; 
}
```
shift — берёт первый аргумент из списка параметров подпрограммы. Если аргумента нет, возвращает undef.

```// '' ```— если пришёл undef, подставляется пустая строка ''. Это защита от ошибок.

```$s =~ s/^\s+|\s+$//g;``` — регулярное выражение, удаляет пробелы, табы и прочие whitespace в начале ```(^\s+)``` и в конце ```(\s+$)``` строки.
``|`` — «или»; ```g ```— глобально (оба конца).

```return $s;``` — возвращает «обрезанную» строку.

#### read_nonempty
```
sub read_nonempty {
    my ($prompt) = @_;
    while (1) {
        print $prompt;
        chomp( my $v = <> // '' );
        $v = trim($v);
        return $v if length $v;
        print "Поле не может быть пустым. Попробуйте ещё раз.\n";
    }
}
```
Принимает один аргумент $prompt — строка-приглашение (например, "ФИО: ").

```while (1)``` — бесконечный цикл до тех пор, пока пользователь не введёт что-то непустое.

```<> // ''``` — считывает строку из ввода или подставляет пустую строку, если EOF.

```chomp``` убирает \n в конце.

```$v = trim($v);``` — удаляет пробелы с краёв.

```return $v if length $v;``` — если строка непустая, возвращаем её и выходим из цикла/функции.

Если пустая — выводим предупреждение и повторяем запрос.

#### read_date
```
sub read_date {
    while (1) {
        print "Дата рождения (дд.мм.гггг): ";
        chomp( my $d = <> // '' );
        $d = trim($d);
        if ( validate_date($d) ) {
            return $d;
        } else {
            print "Неверная дата. Ожидается корректная дата в формате дд.мм.гггг (год $MIN_YEAR..$MAX_YEAR).\n";
        }
    }
}
```
Бесконечный цикл — пока не получим корректную дату.
Считываем строку, чистим пробелы.

```if ( validate_date($d) )``` — проверяем дату с помощью отдельной функции.

Если дата корректна → возвращаем её.

Если нет → пишем сообщение об ошибке и цикл повторяется.

#### validate_date
```
sub validate_date {
    my ($d) = @_;
    return 0 unless defined $d;
    return 0 unless $d =~ /^(\d{2})\.(\d{2})\.(\d{4})$/;
    my ($dd, $mm, $yy) = ($1+0, $2+0, $3+0);

    return 0 if $yy < $MIN_YEAR || $yy > $MAX_YEAR;
    return 0 if $mm < 1 || $mm > 12;

    my @mdays = (0,31,28,31,30,31,30,31,31,30,31,30,31);
    # високосный год
    if ( $mm == 2 ) {
        my $is_leap = ($yy % 4 == 0 && ($yy % 100 != 0 || $yy % 400 == 0));
        $mdays[2] = 29 if $is_leap;
    }
    return 0 if $dd < 1 || $dd > $mdays[$mm];
    return 1;
}
```
Принимает дату как строку.

```return 0 unless defined $d;``` — если undef, сразу ошибка.

```return 0 unless $d =~ /^(\d{2})\.(\d{2})\.(\d{4})$/;```
Проверяем формат: ровно 2 цифры, точка, 2 цифры, точка, 4 цифры.
Если не совпадает — возвращаем 0 (ошибка).
Если совпадает, то:

$1 — день, $2 — месяц, $3 — год.

+0 преобразует строки в числа.

Проверяем год ($yy) в диапазоне [MIN_YEAR, MAX_YEAR].

Проверяем, что месяц ($mm) в диапазоне 1..12.

@mdays — массив количества дней в месяцах (февраль пока 28).

Если месяц февраль, проверяем високосный год:

Год високосный, если делится на 4, но не на 100, или делится на 400.

Если високосный, то в феврале 29 дней.

Проверяем, что день ($dd) от 1 до максимума в данном месяце.

Если всё ок → return 1 (корректная дата).

Иначе return 0.

### Рекурсивные подпрограммы

#### sub insert
```
sub insert {
    my ($ref, $student) = @_;
    unless ($$ref) {
        # создаём узел; NEXT обязательно определён
        $$ref = { %$student, NEXT => undef };
        return 1;
    }

    my $newk = lc $student->{ZACH} // '';
    my $curk = lc $$ref->{ZACH} // '';

    if ($newk eq $curk) {
        warn "Такой номер зачетной книжки уже есть!\n";
        return 0;
    }

    if ($newk lt $curk) {
        my $new = { %$student, NEXT => $$ref };
        $$ref = $new;
        return 1;
    }

    return insert(\($$ref->{NEXT}), $student);
}
```

Подпрограмма вставляет студента в односвязный список в отсортированном порядке (по номеру зачётки).

Аргументы:

```$ref``` — ссылка на скаляр, который содержит либо undef, либо хеш-узел списка.
Это позволяет изменять список рекурсивно.

```$student``` — ссылка на хеш с данными нового студента.

```unless ($$ref)``` — если в этом месте списка пусто (undef), значит, нужно создать новый узел.
```$ref``` разворачивается в скаляр (например, $head или $cur->{NEXT}), а $$ref — сам узел.
Создаём новый хеш и присваиваем.

```$newk = lc $student->{ZACH}``` и ```$curk = lc $$ref->{ZACH}``` — приводим номера зачеток к нижнему регистру, чтобы сравнение было нечувствительно к регистру.

Если ключи совпали → пишем предупреждение и не добавляем (возвращаем 0).

Если новый ключ меньше текущего (lt — строковое сравнение) → вставляем перед текущим узлом. Для этого создаём новый узел, в поле NEXT кладём старый $ref, и заменяем $ref на этот новый узел.

Иначе (ключ больше) → рекурсивно вызываем insert для следующего узла: insert(\($$ref->{NEXT}), $student).

В итоге список всегда остаётся отсортированным по ZACH.

#### sub delete_node
```
sub delete_node {
    my ($ref, $zach, $prev) = @_;
    return 0 unless $$ref;

    if ( lc($$ref->{ZACH} // '') eq lc($zach // '') ) {
        if ($prev) {
            # prev — это хеш-реф текущего предыдущего узла
            $prev->{NEXT} = $$ref->{NEXT};
        } else {
            # удаляем голову
            $$ref = $$ref->{NEXT};
        }
        return 1;
    }

    return delete_node(\($$ref->{NEXT}), $zach, $$ref);
}
```

Удаление элемента по номеру зачётки.

Аргументы:

```$ref ```— ссылка на текущий узел (как и в insert).

```$zach ```— номер зачётки, который ищем.

```$prev ```— ссылка на предыдущий узел (нужно, чтобы связать список после удаления).

```return 0 unless $$ref;``` — если список закончился (undef), ничего не нашли → возвращаем 0.

Сравниваем ключи (lc — для нечувствительности к регистру).

Если нашли совпадение:

Если есть предыдущий ```($prev не undef) ```→ «перешиваем» список: у предыдущего NEXT указывает на NEXT текущего.

Если это голова списка → просто сдвигаем голову: ```$$ref = $$ref->{NEXT};.```

Возвращаем 1 (успех).

Если не нашли → рекурсивно ищем дальше: ```delete_node(\($$ref->{NEXT}), $zach, $$ref).```

Таким образом, удаление тоже рекурсивное, и список корректно сшивается после удаления узла.

#### sub list_print
```
sub list_print {
    my ($item) = @_;
    return unless $item;

    printf "ФИО: %s, Зачетка: %s, Группа: %s, Спец: %s, ДР: %s\n",
        $item->{FIO} // '',
        $item->{ZACH} // '',
        $item->{GROUP} // '',
        $item->{SPEC} // '',
        $item->{DOB} // '';

    list_print($item->{NEXT});
}
```

Рекурсивный вывод списка студентов.

Аргумент ```$item ```— текущий узел (хеш).

```return unless $item;``` — если дошли до конца списка (undef), выходим.

```printf ```печатает форматированную строку:

```%s``` → строка.

```// '' ```— если значение undef, подставляем пустую строку, чтобы не упало.

Рекурсивный вызов: ```list_print($item->{NEXT});``` → печать следующего узла.

В результате выводятся все студенты по порядку, как в списке.

## Вторая часть

Подключение модулей и объявление переменных
```
use strict;
use warnings;
use List::Util qw(max);

my $root;  # корень дерева
```

```use strict;``` — запрещает использовать не объявленные переменные, заставляет писать аккуратно.

```use warnings;``` — включает предупреждения, если что-то идёт не так.

```use List::Util qw(max);``` — импорт функции max, чтобы можно было вычислять максимальное значение (используется при вычислении высоты дерева).

```my $root;``` — переменная для корня бинарного дерева. Изначально дерево пустое (undef).

```chomp(my $choice = <> // '');``` — читаем ввод пользователя, убираем символ перевода строки, если пользователь ничего не ввёл, подставляем пустую строку (// '').

```
if ($choice eq '1') {
    print "Сколько чисел сгенерировать? ";
    chomp(my $n = <> // 0);
    $root = undef;
    for (1 .. $n) {
        my $val = int(rand(100));
        insert(\$root, $val);
    }
    print "Дерево сгенерировано.\n";
}
```

Спрашиваем, сколько чисел нужно вставить.

Сбрасываем дерево: $root = undef.

Генерируем $n случайных чисел от 0 до 99 (int(rand(100))).

Каждый элемент вставляем с помощью функции insert(\$root, $val).

После окончания выводим сообщение, что дерево создано.

```
elsif ($choice eq '2') {
    print "Введите число: ";
    chomp(my $val = <> // '');
    if ($val =~ /^-?\d+$/) {
        insert(\$root, $val);
        print "Элемент $val добавлен.\n";
    } else {
        print "Ошибка: нужно ввести целое число.\n";
    }
}
```

Пользователь вводит число.

Проверка регуляркой /^-?\d+$/: число может быть отрицательным (-?), затем одна или более цифр.

Если проверка пройдена — вставляем элемент в дерево через insert.

Иначе выводим ошибку.

```
elsif ($choice eq '3') {
    if ($root) {
        print "\nСтруктура дерева:\n";
        print_tree($root, "", 0);
    } else {
        print "Дерево пустое.\n";
    }
}
```

Проверяем, пусто ли дерево.

Если есть элементы — вызываем print_tree($root, "", 0) для бокового вывода с ветками.

Если дерево пустое — пишем сообщение.

```
elsif ($choice eq '4') {
    if ($root) {
        print "\nДерево по уровням:\n";
        print_tree_levels($root);
    } else {
        print "Дерево пустое.\n";
    }
}
```

Используется функция print_tree_levels($root).

```
elsif ($choice eq '5') {
    print "Введите число для удаления: ";
    chomp(my $val = <> // '');
    if ($val =~ /^-?\d+$/) {
        if (delete_node(\$root, $val)) {
            print "Элемент $val удалён.\n";
        } else {
            print "Элемент $val не найден.\n";
        }
    } else {
        print "Ошибка: нужно ввести целое число.\n";
    }
}
```

Пользователь вводит число для удаления.

Проверяем, что это целое число.

Вызов delete_node(\$root, $val) удаляет узел, если он есть.

```
elsif ($choice eq '6') {
    last;
}
else {
    print "Неверный выбор!\n";
}
```

```last — прерывает цикл while(1)```, программа завершается.

### Вспомогательные подпрограммы

#### trim
```
sub trim { my $s = shift // ''; $s =~ s/^\s+|\s+$//g; return $s; }
```

Аргумент: берёт строку ```$s.```

```shift // ''```: если не передан аргумент, заменяет undef на пустую строку.

Регулярка: ```s/^\s+|\s+$//g``` удаляет все пробелы в начале ```(^\s+) ```и в конце ```(\s+$).```

#### read_nonempty
```
sub read_nonempty {
    my ($prompt) = @_;
    while (1) {
        print $prompt;
        chomp( my $v = <> // '' );
        $v = trim($v);
        return $v if length $v;
        print "Поле не может быть пустым. Попробуйте ещё раз.\n";
    }
}
```

Аргумент: ```$prompt``` — текст, который выводится пользователю.

Цикл: пока пользователь не введёт непустую строку.

```chomp``` — убирает символ перевода строки.

```trim ```— удаляет пробелы по краям.

```return $v if length $v```; — если строка непустая, возвращаем её.

Иначе: печатаем предупреждение и повторяем ввод.

#### read_date
```
sub read_date {
    while (1) {
        print "Дата рождения (дд.мм.гггг): ";
        chomp( my $d = <> // '' );
        $d = trim($d);
        if ( validate_date($d) ) {
            return $d;
        } else {
            print "Неверная дата. Ожидается корректная дата в формате дд.мм.гггг (год $MIN_YEAR..$MAX_YEAR).\n";
        }
    }
}
```

Запрашивает дату у пользователя.

Использует trim, чтобы убрать лишние пробелы.

Проверяет корректность через функцию validate_date.

Если дата неверная — выводит сообщение и повторяет запрос.

#### validate_date
```
sub validate_date {
    my ($d) = @_;
    return 0 unless defined $d;
    return 0 unless $d =~ /^(\d{2})\.(\d{2})\.(\d{4})$/;
    my ($dd, $mm, $yy) = ($1+0, $2+0, $3+0);

    return 0 if $yy < $MIN_YEAR || $yy > $MAX_YEAR;
    return 0 if $mm < 1 || $mm > 12;

    my @mdays = (0,31,28,31,30,31,30,31,31,30,31,30,31);
    if ( $mm == 2 ) {
        my $is_leap = ($yy % 4 == 0);
        $mdays[2] = 29 if $is_leap;
    }
    return 0 if $dd < 1 || $dd > $mdays[$mm];
    return 1;
}
```

Проверка на undef: ```return 0 unless defined $d;``` — если дата не задана, она некорректна.

Регулярка: ```^(\d{2})\.(\d{2})\.(\d{4})$```

```\d{2}``` — две цифры (день и месяц)

```\d{4}``` — четыре цифры (год)

```^ и $ ```— строка должна полностью соответствовать формату

Преобразование: $1+0 — превращает строку с цифрами в число.

Проверка диапазона года: $yy >= $MIN_YEAR && $yy <= $MAX_YEAR.

Проверка месяца: $mm от 1 до 12.

Проверка числа дней:

Массив @mdays хранит количество дней в каждом месяце.

Февраль (2 месяц) корректируется для високосного года: если $yy % 4 == 0 → 29 дней.

Проверка дня: $dd должно быть не меньше 1 и не больше $mdays[$mm].

Если всё ок: return 1; → дата корректна.

### Рекурсивные подпрограммы

#### insert
```
sub insert {
    my ($ref, $student) = @_;
    unless ($$ref) {
        $$ref = { %$student, NEXT => undef };
        return 1;
    }

    my $newk = lc $student->{ZACH} // '';
    my $curk = lc $$ref->{ZACH} // '';

    if ($newk eq $curk) {
        warn "Такой номер зачетной книжки уже есть!\n";
        return 0;
    }

    if ($newk lt $curk) {
        my $new = { %$student, NEXT => $$ref };
        $$ref = $new;
        return 1;
    }

    return insert(\($$ref->{NEXT}), $student);
}
```

```my ($ref, $student) = @_;```

```$ref``` — ссылка на ссылку на узел списка.

```$student``` — хеш с информацией о студенте (FIO, ZACH, GROUP, SPEC, DOB).

```unless ($$ref)```

Если текущий узел пустой (список пуст или дошли до конца), создаём новый элемент.

```$$ref = { %$student, NEXT => undef };``` — создаём новый хеш с полем NEXT, указывающим на следующий элемент (пока нет → undef).

```return 1;``` — вставка успешна.

Сравнение ключей (ZACH) нечувствительно к регистру:
```
my $newk = lc $student->{ZACH} // '';
my $curk = lc $$ref->{ZACH} // '';
```

Проверка на дубликат:
```
if ($newk eq $curk) {
    warn "Такой номер зачетной книжки уже есть!\n";
    return 0;
}
```
Если ключ уже существует, выводим предупреждение и выходим.

Вставка перед текущим элементом, если ключ меньше:
```
if ($newk lt $curk) {
    my $new = { %$student, NEXT => $$ref };
    $$ref = $new;
    return 1;
}
```
Новый узел становится текущей головой подсписка, а текущий элемент смещается вниз (NEXT).

Рекурсивный вызов для следующего элемента:
```
return insert(\($$ref->{NEXT}), $student);
```
Если ключ больше, идём дальше по списку.

#### delete_node
```
sub delete_node {
    my ($ref, $zach, $prev) = @_;
    return 0 unless $$ref;

    if ( lc($$ref->{ZACH} // '') eq lc($zach // '') ) {
        if ($prev) {
            $prev->{NEXT} = $$ref->{NEXT};
        } else {
            $$ref = $$ref->{NEXT};
        }
        return 1;
    }

    return delete_node(\($$ref->{NEXT}), $zach, $$ref);
}
```

```$ref ```— ссылка на текущий узел, ```$zach``` — ключ для удаления, $prev — ссылка на предыдущий узел.

```return 0 unless $$ref;``` Если узел пустой, значит элемент не найден.

Проверка ключа:
```
if ( lc($$ref->{ZACH} // '') eq lc($zach // '') )
``` Сравниваем без учёта регистра.

Удаление:

Если есть предыдущий узел ($prev), просто меняем его NEXT на следующий узел текущего:
```
$prev->{NEXT} = $$ref->{NEXT};
```
Если удаляем голову списка, меняем ссылку $ref на следующий элемент:
```
$$ref = $$ref->{NEXT};
```
Возврат 1 — элемент удалён.

Рекурсивный вызов, если элемент ещё не найден:
```
return delete_node(\($$ref->{NEXT}), $zach, $$ref);
```
#### list_print
```
sub list_print {
    my ($item) = @_;
    return unless $item;

    printf "ФИО: %s, Зачетка: %s, Группа: %s, Спец: %s, ДР: %s\n",
        $item->{FIO} // '',
        $item->{ZACH} // '',
        $item->{GROUP} // '',
        $item->{SPEC} // '',
        $item->{DOB} // '';

    list_print($item->{NEXT});
}
```

```$item ```— текущий узел списка.

```return unless $item;``` — если узел пустой, выходим.

```printf ```— форматированный вывод данных студента.

Рекурсивный вызов:
```
list_print($item->{NEXT});
```
Печатаем следующий элемент списка, пока не дойдём до конца.

## Третья часть

```print "Введите число дисков: ";
chomp(my $n = <> // 0);
$n = int($n);
print "Введите число дисков: ";```

```<> ```— считывает строку из стандартного ввода (обычно клавиатура).

```// 0 ```— оператор defined-or, если пользователь не ввёл ничего, присвоим $n = 0.

```chomp(...)``` — удаляет символ перевода строки \n из введённой строки.

```$n = int($n);``` — превращаем введённое значение в целое число (отбрасываем дробную часть, если она случайно есть).

#### Проверка корректности числа
```
die "Неверное число дисков\n" if $n <= 0;
```
Если пользователь ввёл 0 или отрицательное число, программа завершает работу с сообщением "Неверное число дисков".

```die``` — стандартная функция Perl для аварийного завершения программы с сообщением.

#### Инициализация стержней
```
my %rods = (
    a => [reverse 1..$n],  # на a диски от n (большой) до 1 (малый)
    b => [],
    c => [],
);
```
```
```%rods ```— хеш, где ключи: ```a, b, c ```— имена трёх стержней.

Значения — ссылки на массивы, каждый массив хранит размеры дисков на соответствующем стержне.

Разбор инициализации:

```1..$n ```— диапазон от 1 до $n, где 1 — маленький диск, $n — большой.

```reverse 1..$n ```— переворачиваем массив, чтобы в начале стоял большой диск, а маленький — в конце (как на настоящей башне).

Например, если $n = 3 → [3, 2, 1].

```b => [] и c => [] ```— стержни b и c пустые, пока диски на них не перенесены.

#### Функция печати состояния стержней
```
sub print_rods {
    foreach my $rod (qw(a b c)) {
        print "$rod: [", join(", ", @{$rods{$rod}}), "]\n";
    }
    print "\n";
}
```

```foreach my $rod (qw(a b c)) ```— перебираем ключи хеша a, b, c.

```qw(a b c)``` — короткая запись для списка ('a', 'b', 'c').

```@{$rods{$rod}}``` — разыменовываем ссылку на массив для текущего стержня.

```join(", ", @{$rods{$rod}})``` — объединяем элементы массива через запятую, чтобы красиво вывести их как список.

```print "$rod: [...]\n";``` — выводим имя стержня и его содержимое.

```print "\n";``` — добавляем пустую строку после всех трёх стержней для визуального разделения.

Объявление рекурсивной функции
```
sub hanoi {
    my ($num, $from, $to, $aux) = @_;
```

```sub hanoi { ... } ```— объявляем функцию hanoi.

Аргументы функции:

```$num ```— количество дисков, которые нужно переместить с $from на $to.

```$from``` — имя стержня, с которого снимаем диски.

```$to``` — имя стержня, на который переносим диски.

```$aux ```— вспомогательный стержень, через который будем перемещать промежуточные диски.


 Базовый случай рекурсии
    ```return if $num == 0;```


Если количество дисков равно 0, ничего делать не нужно → просто выходим из функции.


Рекурсивный шаг 1 — перенос n-1 дисков на вспомогательный стержень
    ```hanoi($num-1, $from, $aux, $to);```


Идея: чтобы перенести n дисков с $from на $to, сначала переносим верхние n-1 дисков на $aux, оставляя самый большой диск на $from.

 Этот вызов рекурсивно повторяется до базового случая ($num == 0).

Перенос самого большого диска
    ```my $disk = pop @{$rods{$from}};
    push @{$rods{$to}}, $disk;```


```pop @{$rods{$from}}``` — снимаем верхний диск со стержня $from.

```push @{$rods{$to}}, $disk``` — ставим его на стержень $to.

Этот диск — самый большой среди текущих num дисков, поэтому его можно безопасно перемещать на целевой стержень.
```
    print "Перенос диска диаметра $disk со стержня $from на стержень $to.\n";
    print_rods();
```

Выводим сообщение о перемещении.

```Функция print_rods()``` печатает текущее состояние всех трёх стержней после хода.

Рекурсивный шаг 2 — перенос n-1 дисков с вспомогательного стержня на целевой
    ```hanoi($num-1, $aux, $to, $from);```


Теперь переносим верхние n-1 дисков с $aux на $to, чтобы закончить перенос всей группы.

Этот шаг рекурсивно повторяет ту же логику, что и первый шаг.


7️⃣ Запуск рекурсии
```hanoi($n, 'a', 'c', 'b');```


Перемещаем $n дисков с a на c через b.

В этом месте рекурсивно выполняются все перемещения дисков, начиная с верхнего и заканчивая большим.

8️⃣ Завершение
print "Все диски перенесены на стержень c.\n";


Сообщение о том, что задача решена.
